# ______________________________________________________________________
#
#    This module is part of the PyMINLP solver framework.
# ______________________________________________________________________


from pyomo.environ import *
from pyminlp.solver import PyMINLP
from pyminlp.subprob import *
from pyminlp.plugins.quad import *


def foo(filename):

    # Create model instance first.
    model = createInstance(filename)

    # Display read instance.
    #model.pprint()

    # Set up solver.
    solver = PyMINLP()
    solver.use_constraint_handler(name='linear', constypes=['Quadcons', 'Cuts'],
                                  identify_prio=1, relaxation=True)
    solver.use_constraint_handler(name='quadconv', constypes=['Quadcons'],
                                  identify_prio=2, relaxation=False)
    solver.use_constraint_handler(name='quadnonc', constypes=['Quadcons'],
                                  identify_prio=3, relaxation=False)

    solver.solve(model)

    # Testing
    int_inst = Instance.create_instance(model)
    testing(model, int_inst)

    # Doing stuff with the constraint classifiers.

    print('Done')


def testing(model, int_inst):

    clone = model.clone()
    new_cons = clone.Quadcons
    par_A = clone.A
    par_b = clone.b
    par_c = clone.c

    clone.k = Param(initialize=3)
    k = clone.k

    xyz = par_A['e1',:,:]

    int_inst.add_constraints('Cons', new_cons,
                             {'cn':par_c, 'An':par_A, 'bn':par_b, 'kn':k})

    int_inst.change_varbounds(model.X['x1'].name, lower_bound=-5.0, upper_bound=5.0)


def createInstance( filename ):
    """Find the model specification in this function. It creates an
    instance of this model using the provided data file and returns this
    instance.
    """

    # Create an abstract model for a QCQP with linear objective
    model = AbstractModel()

    # Sets
    model.C = Set()
    model.V = Set()

    # Constraint parameters
    model.A = Param(model.C, model.V, model.V, default=0)
    model.b = Param(model.C, model.V, default=0)
    model.c = Param(model.C, default=0)

    # Constraint bounds
    model.cl = Param(model.C)
    model.cu = Param(model.C)

    # Variable bounds
    model.xl = Param(model.V)
    model.xu = Param(model.V)

    # Objective function parameters
    model.z = Param(model.V, default=0)

    # Bounds
    def var_bounds_rule(model, k):
        return model.xl[k], model.xu[k]

    # Variables
    model.X = Var(model.V, bounds=var_bounds_rule, domain=Reals)

    # Objective
    def obj_rule(model):
        return sum(model.z[k] * model.X[k] for k in model.V)
    model.Obj = Objective(rule=obj_rule, sense=minimize)

    # Constraints
    def cons_rule(model, i):
        quad = sum(sum(model.A[i, k1, k2] * model.X[k1] * model.X[k2]
                       for k1 in model.V) for k2 in model.V)
        lin = sum(model.b[i, k] * model.X[k] for k in model.V) + model.c[i]
        return model.cl[i], quad + lin, model.cu[i]
    model.Quadcons = Constraint(model.C, rule=cons_rule)

    instance = model.create_instance(filename)

    return instance
